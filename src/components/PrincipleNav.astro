---
import Button from './Button.astro';
import Icon from './Icon.astro';
import categoriesData from '../data/categories.json';
import designSystemsData from '../data/design-systems.json';
import userCenteredDesignData from '../data/user-centered-design.json';
import humanCenteredAiDesignData from '../data/human-centered-ai-design.json';
import Nav from './Nav.astro';
import PrincipleNavButton from './PrincipleNavButton.astro';

interface Props {
  baseUrl: string;
  currentPrincipleId: string;
  sectionPath: string;
  allPrinciples: Array<{ id: string; title: string }>;
}

const { baseUrl, currentPrincipleId, sectionPath, allPrinciples } = Astro.props;

// Map section paths to their data
const sectionDataMap: Record<string, { principles: Array<{ id: string; title: string }> }> = {
  '/design-systems': designSystemsData,
  '/user-centered-design': userCenteredDesignData,
  '/human-centered-ai-design': humanCenteredAiDesignData,
};

// Filter out draft categories in production (show them in development)
const visibleCategories = categoriesData.filter(
  (category) => !(category as any).draft || !import.meta.env.PROD
);

const allSections = visibleCategories.map((cat) => cat.path);
const currentSectionIndex = allSections.findIndex((path) => path === sectionPath);

const sortedPrinciples = [...allPrinciples].sort((a, b) => a.title.localeCompare(b.title));
const currentIndex = sortedPrinciples.findIndex((p) => p.id === currentPrincipleId);
const currentPrinciple = sortedPrinciples[currentIndex];

let prevPrinciple = currentIndex > 0 ? sortedPrinciples[currentIndex - 1] : null;
let prevSectionPath = sectionPath;
let nextPrinciple =
  currentIndex < sortedPrinciples.length - 1 ? sortedPrinciples[currentIndex + 1] : null;
let nextSectionPath = sectionPath;

if (currentIndex === 0) {
  if (currentSectionIndex > 0) {
    const targetSectionPath = allSections[currentSectionIndex - 1];
    const targetSectionData = sectionDataMap[targetSectionPath];
    if (targetSectionData && targetSectionData.principles.length > 0) {
      const targetSectionSorted = [...targetSectionData.principles].sort((a, b) =>
        a.title.localeCompare(b.title)
      );
      prevPrinciple = targetSectionSorted[targetSectionSorted.length - 1];
      prevSectionPath = targetSectionPath;
    }
  } else {
    const targetSectionPath = allSections[allSections.length - 1];
    const targetSectionData = sectionDataMap[targetSectionPath];
    if (targetSectionData && targetSectionData.principles.length > 0) {
      const targetSectionSorted = [...targetSectionData.principles].sort((a, b) =>
        a.title.localeCompare(b.title)
      );
      prevPrinciple = targetSectionSorted[targetSectionSorted.length - 1];
      prevSectionPath = targetSectionPath;
    }
  }
}

if (currentIndex === sortedPrinciples.length - 1) {
  if (currentSectionIndex < allSections.length - 1) {
    const targetSectionPath = allSections[currentSectionIndex + 1];
    const targetSectionData = sectionDataMap[targetSectionPath];
    if (targetSectionData && targetSectionData.principles.length > 0) {
      const targetSectionSorted = [...targetSectionData.principles].sort((a, b) =>
        a.title.localeCompare(b.title)
      );
      nextPrinciple = targetSectionSorted[0];
      nextSectionPath = targetSectionPath;
    }
  } else {
    const targetSectionPath = allSections[0];
    const targetSectionData = sectionDataMap[targetSectionPath];
    if (targetSectionData && targetSectionData.principles.length > 0) {
      const targetSectionSorted = [...targetSectionData.principles].sort((a, b) =>
        a.title.localeCompare(b.title)
      );
      nextPrinciple = targetSectionSorted[0];
      nextSectionPath = targetSectionPath;
    }
  }
}

const prevUrl = prevPrinciple
  ? prevSectionPath !== sectionPath
    ? `${baseUrl}${prevSectionPath}`
    : `${baseUrl}${prevSectionPath}/${prevPrinciple.id}`
  : null;
const nextUrl = nextPrinciple
  ? nextSectionPath !== sectionPath
    ? `${baseUrl}${nextSectionPath}`
    : `${baseUrl}${nextSectionPath}/${nextPrinciple.id}`
  : null;

const isPrevDifferentSection = prevSectionPath !== sectionPath;
const isNextDifferentSection = nextSectionPath !== sectionPath;

const prevSection = isPrevDifferentSection
  ? visibleCategories.find((cat) => cat.path === prevSectionPath)
  : null;
const nextSection = isNextDifferentSection
  ? visibleCategories.find((cat) => cat.path === nextSectionPath)
  : null;

const prevIcon =
  isPrevDifferentSection && prevSection
    ? (prevSection as { icon?: string }).icon
    : 'mi/outline/arrow-back';
const nextIcon =
  isNextDifferentSection && nextSection
    ? (nextSection as { icon?: string }).icon
    : 'mi/outline/arrow-forward';
---

<Nav position="bottom" data-bottom-nav>
  {
    prevUrl && (
      <PrincipleNavButton
        title={
          isPrevDifferentSection && prevSection
            ? prevSection.title
            : prevPrinciple?.title || 'Previous principle'
        }
        description={
          isPrevDifferentSection && prevSection ? prevSection.title : 'Previous principle'
        }
        href={prevUrl}
        direction="previous"
        icon={prevIcon}
      />
    )
  }
  {
    nextUrl && (
      <PrincipleNavButton
        title={
          isNextDifferentSection && nextSection
            ? nextSection.title
            : nextPrinciple?.title || 'Next principle'
        }
        description={isNextDifferentSection && nextSection ? nextSection.title : 'Next principle'}
        href={nextUrl}
        direction="next"
        icon={nextIcon}
      />
    )
  }
</Nav>

<script>
  function initPrincipleBottomNavVisibility() {
    const bottomNav = document.querySelector('[data-bottom-nav]') as HTMLElement | null;
    const article = document.querySelector('.page-article') as HTMLElement | null;
    if (!bottomNav) return;

    function getReadingProgress(): number {
      if (!article) return 0;
      const rect = article.getBoundingClientRect();
      const viewportH = window.innerHeight;
      const articleH = article.offsetHeight;
      const scrollable = articleH - viewportH;
      if (scrollable <= 0) return 100;
      const progress = -rect.top / scrollable;
      return Math.round(Math.max(0, Math.min(1, progress)) * 100);
    }

    function updateBottomNavOpacity() {
      const percent = getReadingProgress();
      if (!bottomNav) return;

      if (percent > 0 && percent < 100) {
        bottomNav.classList.remove('translate-y-full');
        bottomNav.classList.add('translate-y-0');
      } else {
        bottomNav.classList.remove('translate-y-0');
        bottomNav.classList.add('translate-y-full');
      }
    }

    updateBottomNavOpacity();
    window.addEventListener('scroll', updateBottomNavOpacity, { passive: true });
    window.addEventListener('resize', updateBottomNavOpacity);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initPrincipleBottomNavVisibility();
    });
  } else {
    initPrincipleBottomNavVisibility();
  }
</script>
