---
import Button from './Button.astro';
import Icon from './Icon.astro';
import HeaderLogo from './HeaderLogo.astro';
import HeaderMenu from './HeaderMenu.astro';
import personalData from '../data/personal.json';

interface Props {
  items?: Array<{
    href: string;
    label: string;
    icon: string;
    button: string;
    current: number;
    headerSelected?: string;
  }>;
  menu?: boolean;
}

// Get base URL from Astro config and normalize it
// Remove trailing slash if present (except for root)
const rawBaseUrl = import.meta.env.BASE_URL;
const baseUrl = rawBaseUrl === '/' ? '' : rawBaseUrl.replace(/\/$/, '');
const { menu = true } = Astro.props;
---

<header class="header flex items-center gap-400 justify-between group/header">
  <div class="inline-flex items-center gap-400">
    <HeaderLogo />
    <div class="hidden desktop:grid">
      <h1 class="text-title-h3" aria-label="Vittorio Vittori">
        Vittori<mds-text
          aria-hidden="true"
          class="inline-block animate-pulse-more group-hover/header:animate-none group-hover/header:opacity-100"
          tag="span"
          typography="h3"
          animation="jugop"
          text="o"
          data-name></mds-text>
      </h1>
      <mds-text
        tag="span"
        class="header-role min-h-200"
        typography="option"
        data-claims={JSON.stringify(personalData.claims)}
        data-roles={personalData.role}
        text={personalData.role.split('/')[0]}
        animation="jugop"></mds-text>
    </div>
  </div>
  {
    menu ? (
      <HeaderMenu />
    ) : (
      <Button href={baseUrl || '/'} variant="light" class="shrink-0 py-300" title="Back to Home">
        <Icon name="mi/outline/home" class="text-tone-neutral-04" />
      </Button>
    )
  }
</header>

<script>
  function initHeaderHover() {
    const header = document.querySelector('header');
    const mdsText = document.querySelector('mds-text[data-name]');
    const mdsTextRole = document.querySelector('[data-roles]');
    const duration = 5000;

    if (!header || !mdsText || !mdsTextRole) return;

    const textRoles = mdsTextRole.getAttribute('data-roles')?.split('/') || [];
    const claimsAttr = mdsTextRole.getAttribute('data-claims');
    const parsedClaims = claimsAttr ? JSON.parse(claimsAttr) : [];

    // Shuffle claims array to randomize order on each page load
    const textClaims = [...parsedClaims];
    for (let i = textClaims.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [textClaims[i], textClaims[j]] = [textClaims[j], textClaims[i]];
    }

    if (textRoles.length === 0) return;

    let currentRoleIndex = 1;
    let nextClaimIndex = -1; // Start at -1 so first hover shows index 0
    let roleInterval: number | null = null;
    let claimInterval: number | null = null;
    let isHovering = false;

    function updateRoleText() {
      if (!isHovering && textRoles.length > 0 && mdsTextRole) {
        mdsTextRole.setAttribute('text', textRoles[currentRoleIndex] || '');
        currentRoleIndex = (currentRoleIndex + 1) % textRoles.length;
      }
    }

    function updateClaimText() {
      if (isHovering && textClaims.length > 0 && mdsTextRole) {
        mdsTextRole.setAttribute('text', textClaims[nextClaimIndex] || '');
        nextClaimIndex = (nextClaimIndex + 1) % textClaims.length;
      }
    }

    function startRoleRotation() {
      if (roleInterval) return; // Already running
      roleInterval = window.setInterval(updateRoleText, duration);
    }

    function stopRoleRotation() {
      if (roleInterval) {
        clearInterval(roleInterval);
        roleInterval = null;
      }
    }

    function startClaimRotation() {
      if (claimInterval) return; // Already running
      if (textClaims.length > 0) {
        // Advance to next claim (first hover: -1 -> 0, second hover: 0 -> 1, etc.)
        nextClaimIndex = (nextClaimIndex + 1) % textClaims.length;
        // Show the current claim immediately
        if (mdsTextRole) {
          mdsTextRole.setAttribute('text', textClaims[nextClaimIndex] || '');
        }
        // Then cycle through the rest
        claimInterval = window.setInterval(updateClaimText, duration);
      }
    }

    function stopClaimRotation() {
      if (claimInterval) {
        clearInterval(claimInterval);
        claimInterval = null;
      }
    }

    header.addEventListener('mouseenter', () => {
      isHovering = true;
      stopRoleRotation();
      mdsText.setAttribute('text', 'o Vittori');
      // Show the next claim (will advance each hover, restarting after cycling through all)
      startClaimRotation();
    });

    header.addEventListener('mouseleave', () => {
      isHovering = false;
      stopClaimRotation();
      mdsText.setAttribute('text', 'o');
      // Reset to first role and start rotation
      updateRoleText();
      startRoleRotation();
    });

    // Start rotation on page load
    startRoleRotation();
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initHeaderHover);
  } else {
    initHeaderHover();
  }
</script>
