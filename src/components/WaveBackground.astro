---
/**
 * Interactive Wave Background Component
 * 
 * Configuration:
 * - numStripes: Number of horizontal stripes (default: 20)
 * - waveForce: Wave intensity/strength (0-1, default: 0.5)
 * - defaultColor: Default stripe color in hex format (default: '#ff1493' hot pink)
 * 
 * Features:
 * - Mouse interaction creates ripple effects
 * - Hovering category cards changes wave colors
 * - Smooth color transitions
 * - Responsive to window resize
 */
const numStripes = 20; // Number of stripes
const waveForce = 0.5; // Wave intensity (0-1)
const defaultColor = '#ff1493'; // Default hot pink color
---

<div id="wave-background" class="absolute inset-0 -z-10 pointer-events-none"></div>

<script type="module" define:vars={{ numStripes, waveForce, defaultColor }}>
  // Import Three.js from CDN
  (async () => {
    const THREE = await import('https://esm.sh/three@0.160.0');

    // Category colors mapping (extracted from gradient colors)
    const categoryColors = {
      'user-centered-design': '#3b82f6', // blue
      'design-systems': '#8b5cf6', // violet
      'hax-principles': '#10b981', // green
    };

    let scene;
    let camera;
    let renderer;
    let material;
    let mouse = { x: 0, y: 0 };
    let targetColor = new THREE.Color(defaultColor);
    let currentColor = new THREE.Color(defaultColor);
    let animationId;

    function init() {
      const container = document.getElementById('wave-background');
      if (!container) {
        console.warn('WaveBackground: Container not found');
        return;
      }
      
      console.log('WaveBackground: Initializing...');

    // Scene setup
    scene = new THREE.Scene();
    
    // Camera setup (orthographic for 2D effect)
    const width = window.innerWidth;
    const height = window.innerHeight;
    camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 1, 1000);
    camera.position.z = 1;

    // Renderer setup
    renderer = new THREE.WebGLRenderer({ 
      alpha: true, 
      antialias: true,
      powerPreference: 'high-performance'
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0); // Transparent background
    container.appendChild(renderer.domElement);
    
    console.log('WaveBackground: Canvas created', renderer.domElement);

    // Create plane geometry with more segments for better water simulation
    // More segments = smoother water physics
    const segments = Math.max(64, Math.floor(width / 20));
    const geometry = new THREE.PlaneGeometry(width, height, segments, segments);

    // Shader material for wave effect
    material = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uMouse: { value: new THREE.Vector2(0, 0) },
        uColor: { value: currentColor },
        uNumStripes: { value: numStripes },
        uWaveForce: { value: waveForce },
        uResolution: { value: new THREE.Vector2(width, height) },
        uBaseMovement: { value: 0.15 } // Base movement speed for continuous water motion
      },
      vertexShader: `
        uniform float uTime;
        uniform vec2 uMouse;
        uniform float uWaveForce;
        uniform vec2 uResolution;
        uniform float uBaseMovement;
        
        varying vec2 vUv;
        varying float vWave;
        varying vec3 vNormal;
        
        // Water physics simulation based on wave equation
        // This simulates realistic water movement with wave propagation
        
        void main() {
          vUv = uv;
          
          vec3 pos = position;
          
          // Normalize coordinates
          vec2 st = vec2(pos.x / uResolution.x, pos.y / uResolution.y);
          
          // Base continuous water movement - always moving
          float baseWave = sin(st.x * 3.14159 * 2.0 + uTime * uBaseMovement) * 
                          cos(st.y * 3.14159 * 2.0 + uTime * uBaseMovement * 0.7) * 
                          uWaveForce * 0.3;
          
          // Multiple wave frequencies for realistic water physics
          // Each wave has different speed and direction
          float wave1 = sin((st.x + st.y) * 4.0 + uTime * 0.8) * uWaveForce * 0.4;
          float wave2 = sin((st.x - st.y * 0.7) * 5.0 + uTime * 1.1) * uWaveForce * 0.3;
          float wave3 = sin((st.x * 0.7 + st.y) * 6.0 + uTime * 0.9) * uWaveForce * 0.2;
          float wave4 = cos((st.x * 1.3 - st.y * 0.9) * 3.5 + uTime * 1.2) * uWaveForce * 0.25;
          
          // Circular wave patterns for more organic water movement
          vec2 center1 = vec2(0.3, 0.4);
          vec2 center2 = vec2(0.7, 0.6);
          float dist1 = distance(st, center1);
          float dist2 = distance(st, center2);
          
          float circularWave1 = sin(dist1 * 8.0 - uTime * 2.0) * exp(-dist1 * 2.0) * uWaveForce * 0.3;
          float circularWave2 = sin(dist2 * 7.0 - uTime * 1.8) * exp(-dist2 * 2.5) * uWaveForce * 0.25;
          
          // Mouse interaction - water disturbance
          vec2 normalizedMouse = vec2(uMouse.x / uResolution.x, 1.0 - uMouse.y / uResolution.y);
          float mouseDist = distance(st, normalizedMouse);
          
          // Ripple effect from mouse (water physics: wave propagation with damping)
          float mouseRipple = sin(mouseDist * 15.0 - uTime * 8.0) * 
                             exp(-mouseDist * 4.0) * 
                             uWaveForce * 0.8;
          
          // Additional mouse disturbance for more realistic water response
          float mouseDisturbance = cos(mouseDist * 12.0 - uTime * 6.0) * 
                                  exp(-mouseDist * 3.0) * 
                                  uWaveForce * 0.4;
          
          // Combine all waves for realistic water physics
          float totalWave = (baseWave + wave1 + wave2 + wave3 + wave4 + 
                            circularWave1 + circularWave2 + 
                            mouseRipple + mouseDisturbance) * 25.0;
          
          // Apply vertical displacement (water height) - Y for 2D plane
          pos.y += totalWave;
          
          // Calculate normal for lighting/reflection effect (water surface normal)
          float eps = 0.01;
          float waveX = sin((st.x + eps + st.y) * 4.0 + uTime * 0.8) * uWaveForce * 0.4;
          float waveXDiff = waveX - totalWave;
          float waveY = sin((st.x + st.y + eps) * 4.0 + uTime * 0.8) * uWaveForce * 0.4;
          float waveYDiff = waveY - totalWave;
          
          vNormal = normalize(vec3(-waveXDiff * 0.5, -waveYDiff * 0.5, 1.0));
          vWave = totalWave;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 uColor;
        uniform float uNumStripes;
        uniform vec2 uResolution;
        
        varying vec2 vUv;
        
        void main() {
          vec2 uv = vUv;
          
          // Create stripes
          float stripeIndex = floor(uv.y * uNumStripes);
          float stripe = mod(uv.y * uNumStripes, 1.0);
          
          // Determine if this is an even or odd stripe (0 = even, 1 = odd)
          float isOdd = mod(stripeIndex, 2.0);
          
          // Create smooth stripe edges
          float edge = smoothstep(0.45, 0.5, abs(stripe - 0.5));
          
          // Show color on even stripes (isOdd = 0), transparent on odd stripes (isOdd = 1)
          vec3 color = mix(uColor, vec3(0.0), isOdd);
          
          // Apply edge smoothing
          color = mix(color, vec3(0.0), edge * 0.3);
          
          gl_FragColor = vec4(color, 1.0);
        }
      `,
      transparent: true
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    
    console.log('WaveBackground: Scene setup complete', { numStripes, waveForce, defaultColor });

    // Mouse move handler
    function onMouseMove(event) {
      mouse.x = event.clientX;
      mouse.y = event.clientY;
      
      if (material.uniforms.uMouse) {
        material.uniforms.uMouse.value.set(event.clientX, event.clientY);
      }
    }

    window.addEventListener('mousemove', onMouseMove);

    // Category card hover handlers
    function setupCategoryHovers() {
      const categoryCards = document.querySelectorAll('[data-category-id]');
      
      categoryCards.forEach((card) => {
        const categoryId = card.getAttribute('data-category-id');
        const color = categoryColors[categoryId];
        
        if (color) {
          card.addEventListener('mouseenter', () => {
            targetColor.set(color);
          });
          
          card.addEventListener('mouseleave', () => {
            targetColor.set(defaultColor);
          });
        }
      });
    }

    setupCategoryHovers();

    // Animation loop
    function animate() {
      animationId = requestAnimationFrame(animate);
      
      // Update time (continuous water movement)
      if (material.uniforms.uTime) {
        material.uniforms.uTime.value += 0.016; // ~60fps timing
      }
      
      // Smooth color transition
      currentColor.lerp(targetColor, 0.05);
      if (material.uniforms.uColor) {
        material.uniforms.uColor.value.copy(currentColor);
      }
      
      renderer.render(scene, camera);
    }

    animate();

    // Handle resize
    function onResize() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      
      camera.left = -width / 2;
      camera.right = width / 2;
      camera.top = height / 2;
      camera.bottom = -height / 2;
      camera.updateProjectionMatrix();
      
      renderer.setSize(width, height);
      
      if (material.uniforms.uResolution) {
        material.uniforms.uResolution.value.set(width, height);
      }
      
      // Update geometry
      const mesh = scene.children[0];
      if (mesh && mesh.geometry) {
        const segments = Math.max(64, Math.floor(width / 20));
        mesh.geometry.dispose();
        mesh.geometry = new THREE.PlaneGeometry(width, height, segments, segments);
      }
    }

    window.addEventListener('resize', onResize);

    // Cleanup function
    return () => {
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('resize', onResize);
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      if (renderer) {
        renderer.dispose();
      }
      if (material) {
        material.dispose();
      }
    };
  }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  })();
</script>

<style>
  #wave-background {
    overflow: hidden;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
  }
  
  #wave-background canvas {
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
  }
</style>

