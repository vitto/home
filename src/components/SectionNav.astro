---
import Button from './Button.astro';
import Icon from './Icon.astro';
import categoriesData from '../data/categories.json';
import HeaderLogo from './HeaderLogo.astro';
import Nav from './Nav.astro';

interface Props {
  baseUrl: string;
  sectionPath: string;
  principles?: boolean;
}

const { baseUrl, sectionPath, principles = true } = Astro.props;

// Filter out draft categories in production (show them in development)
const visibleCategories = categoriesData.filter(
  (category) => !(category as any).draft || !import.meta.env.PROD
);

// Get current section info
const currentSection = visibleCategories.find((cat) => cat.path === sectionPath);
const categorySectionUrl = `${baseUrl}${sectionPath}`;
---

<Nav position="top" data-top-nav>
  <div
    class="pointer-events-auto w-full max-w-lg mobile:gap-0 inline-flex justify-between items-center bottom-0 gap-400 p-200 px-400 nav-outline-strong bg-tone-neutral/80 backdrop-blur rounded-full"
  >
    <HeaderLogo />
    <div class="inline-flex items-center gap-400">
      <Button data-scroll-to-top-button href="#" variant="icon" title="Back to top">
        <Icon name="mi/outline/arrow-upward" />
      </Button>
      <Button href="#related-references-and-bibliography" variant="icon" title="Show bibliography">
        <!-- <Icon name="mi/outline/auto-stories" /> -->
        <Icon name="mi/outline/arrow-downward" />
      </Button>
      {
        principles && (
          <Button
            href={categorySectionUrl}
            variant="icon"
            title={`Back to ${currentSection?.title || 'section'}`}
          >
            <Icon name="mi/outline/apps" />
          </Button>
        )
      }
      <Button data-menu-toggle href="#" variant="icon" title="Show categories">
        <Icon name="mi/outline/menu" />
      </Button>
    </div>
  </div>
</Nav>
<script>
  function initSectionNavVisibility() {
    const sectionNav = document.querySelector('[data-top-nav]') as HTMLElement | null;
    const targetElement = document.querySelector('.header') as HTMLElement | null;
    if (!sectionNav || !targetElement) return;

    let lastScrollY = window.scrollY;
    let isScrollingUp = false;
    let isTargetIntersecting = false;

    function updateNavVisibility() {
      if (!sectionNav) return;

      // Show nav only when scrolling up AND targetElement is not intersecting
      const shouldShow = isScrollingUp && !isTargetIntersecting;

      if (shouldShow) {
        sectionNav.classList.remove('-translate-y-full');
        sectionNav.classList.add('translate-y-0');
      } else {
        sectionNav.classList.add('-translate-y-full');
        sectionNav.classList.remove('translate-y-0');
      }
    }

    // Track scroll direction
    window.addEventListener(
      'scroll',
      () => {
        const currentScrollY = window.scrollY;
        isScrollingUp = currentScrollY < lastScrollY;
        lastScrollY = currentScrollY;
        updateNavVisibility();
      },
      { passive: true }
    );

    const observer = new IntersectionObserver(
      ([entry]) => {
        isTargetIntersecting = entry.isIntersecting;
        updateNavVisibility();
      },
      { threshold: 0 }
    );

    observer.observe(targetElement);
  }

  function initScrollToTop() {
    const scrollToTopButton = document.querySelector('[data-scroll-to-top-button]');
    if (!scrollToTopButton) return;

    scrollToTopButton.addEventListener('click', (e) => {
      e.preventDefault();

      // Remove hash from URL if present
      if (window.location.hash) {
        window.history.replaceState(null, '', window.location.pathname + window.location.search);
      }

      window.scrollTo({
        top: 0,
        behavior: 'smooth',
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initSectionNavVisibility();
      initScrollToTop();
    });
  } else {
    initSectionNavVisibility();
    initScrollToTop();
  }
</script>
