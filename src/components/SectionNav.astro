---
import Button from './Button.astro';
import Icon from './Icon.astro';
import categoriesData from '../data/categories.json';
import HeaderLogo from './HeaderLogo.astro';
import Nav from './Nav.astro';
import PrincipleNavContent from './PrincipleNavContent.astro';

interface Props {
  baseUrl: string;
  sectionPath: string;
  principles?: boolean;
  currentPrincipleId?: string;
  allPrinciples?: Array<{ id: string; title: string }>;
  /** When true, show prev/next navigation arrows in principle nav. Default true. */
  arrows?: boolean;
}

const {
  baseUrl,
  sectionPath,
  principles = true,
  currentPrincipleId,
  allPrinciples,
  arrows = false,
} = Astro.props;

const hasPrincipleNavData =
  currentPrincipleId != null && allPrinciples != null && allPrinciples.length > 0;

// Filter out draft categories in production (show them in development)
const visibleCategories = categoriesData.filter(
  (category) => !(category as any).draft || !import.meta.env.PROD
);

// Get current section info
const currentSection = visibleCategories.find((cat) => cat.path === sectionPath);
const categorySectionUrl = `${baseUrl}${sectionPath}`;
---

<Nav position="top" data-top-nav>
  <div
    class="pointer-events-auto w-full max-w-[calc(768px_-_1rem)] mobile:gap-0 inline-flex justify-between items-center bottom-0 gap-400 p-200 px-400 nav-outline bg-tone-neutral/80 backdrop-blur rounded-full"
  >
    <HeaderLogo />
    <div class="inline-flex items-center justify-end gap-400 mobile:gap-200 grow tablet:max-w-2/3">
      <Button
        data-scroll-to-top-button
        href="#"
        variant="icon"
        title="Back to top"
        class="transition-transform duration-200 origin-center scale-0"
      >
        <Icon name="mi/outline/arrow-upward" />
      </Button>
      {
        principles && (
          <Button
            href={categorySectionUrl}
            variant="icon"
            title={`Back to ${currentSection?.title || 'section'}`}
          >
            <Icon name="mi/outline/apps" />
          </Button>
        )
      }
      {
        hasPrincipleNavData && (
          <PrincipleNavContent
            baseUrl={baseUrl}
            currentPrincipleId={currentPrincipleId!}
            sectionPath={sectionPath}
            allPrinciples={allPrinciples!}
            arrows={arrows}
          />
        )
      }

      <Button href="#related-references-and-bibliography" variant="icon" title="Show bibliography">
        <Icon name="mi/outline/auto-stories" />
        <!-- <Icon name="mi/outline/arrow-downward" /> -->
      </Button>

      <Button data-menu-toggle href="#" variant="icon" title="Show categories">
        <Icon name="mi/outline/menu" />
      </Button>
    </div>
  </div>
</Nav>
<script>
  function initSectionNavVisibility() {
    const sectionNav = document.querySelector('[data-top-nav]') as HTMLElement | null;
    const targetElement = document.querySelector('.header') as HTMLElement | null;
    if (!sectionNav || !targetElement) return;

    let isTargetIntersecting = false;
    const SCROLL_TOP_THRESHOLD = 500;

    function updateNavVisibility() {
      if (!sectionNav) return;

      const currentScrollY = window.scrollY;

      // Hide when scroll top is below threshold; show when past threshold and header is not in view
      const shouldShow = currentScrollY >= SCROLL_TOP_THRESHOLD && !isTargetIntersecting;

      if (shouldShow) {
        sectionNav.classList.remove('-translate-y-full');
        sectionNav.classList.add('translate-y-0');
      } else {
        sectionNav.classList.add('-translate-y-full');
        sectionNav.classList.remove('translate-y-0');
      }
    }

    window.addEventListener('scroll', updateNavVisibility, { passive: true });

    const observer = new IntersectionObserver(
      ([entry]) => {
        isTargetIntersecting = entry.isIntersecting;
        updateNavVisibility();
      },
      { threshold: 0 }
    );

    observer.observe(targetElement);
  }

  function initScrollToTop() {
    const scrollToTopButton = document.querySelector(
      '[data-scroll-to-top-button]'
    ) as HTMLElement | null;
    if (!scrollToTopButton) return;

    scrollToTopButton.addEventListener('click', (e) => {
      e.preventDefault();

      // Remove hash from URL if present
      if (window.location.hash) {
        window.history.replaceState(null, '', window.location.pathname + window.location.search);
      }

      window.scrollTo({
        top: 0,
        behavior: 'smooth',
      });
    });
  }

  function initScrollToTopButtonScale() {
    const article = document.querySelector('.page-article') as HTMLElement | null;
    const button = document.querySelector('[data-scroll-to-top-button]') as HTMLElement | null;
    if (!button) return;

    function getReadingProgress(): number {
      if (!article) return 0;
      const rect = article.getBoundingClientRect();
      const viewportH = window.innerHeight;
      const articleH = article.offsetHeight;
      const scrollable = articleH - viewportH;
      if (scrollable <= 0) return 100;
      const progress = -rect.top / scrollable;
      return Math.round(Math.max(0, Math.min(1, progress)) * 100);
    }

    function updateButtonScale() {
      const percent = getReadingProgress();
      if (!button) return;
      if (percent < 30) {
        button.classList.remove('scale-100');
        button.classList.add('scale-0');
        button.setAttribute('tabindex', '-1');
      } else {
        button.classList.remove('scale-0');
        button.classList.add('scale-100');
        button.removeAttribute('tabindex');
      }
    }

    updateButtonScale();
    window.addEventListener('scroll', updateButtonScale, { passive: true });
    window.addEventListener('resize', updateButtonScale);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initSectionNavVisibility();
      initScrollToTop();
      initScrollToTopButtonScale();
    });
  } else {
    initSectionNavVisibility();
    initScrollToTop();
    initScrollToTopButtonScale();
  }
</script>
