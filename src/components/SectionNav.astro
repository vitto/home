---
import Button from './Button.astro';
import Icon from './Icon.astro';
import categoriesData from '../data/categories.json';
import HeaderLogo from './HeaderLogo.astro';
import Nav from './Nav.astro';
import PrincipleNavContent from './PrincipleNavContent.astro';

interface Props {
  baseUrl: string;
  sectionPath: string;
  principles?: boolean;
  currentPrincipleId?: string;
  allPrinciples?: Array<{ id: string; title: string }>;
  /** When true, show prev/next navigation arrows in principle nav. Default true. */
  arrows?: boolean;
}

const {
  baseUrl,
  sectionPath,
  principles = true,
  currentPrincipleId,
  allPrinciples,
  arrows = false,
} = Astro.props;

const hasPrincipleNavData =
  currentPrincipleId != null && allPrinciples != null && allPrinciples.length > 0;

// Filter out draft categories in production (show them in development)
const visibleCategories = categoriesData.filter(
  (category) => !(category as any).draft || !import.meta.env.PROD
);

// Get current section info
const currentSection = visibleCategories.find((cat) => cat.path === sectionPath);
const categorySectionUrl = `${baseUrl}${sectionPath}`;
---

<Nav position="top" data-top-nav>
  <div
    class="pointer-events-auto w-full max-w-lg mobile:gap-0 inline-flex justify-between items-center bottom-0 gap-400 p-200 px-400 nav-outline bg-tone-neutral/80 backdrop-blur rounded-full"
  >
    <HeaderLogo />
    {
      hasPrincipleNavData && (
        <PrincipleNavContent
          baseUrl={baseUrl}
          currentPrincipleId={currentPrincipleId!}
          sectionPath={sectionPath}
          allPrinciples={allPrinciples!}
          arrows={arrows}
        />
      )
    }
    <div class="inline-flex items-center gap-400">
      <Button data-scroll-to-top-button href="#" variant="icon" title="Back to top">
        <Icon name="mi/outline/arrow-upward" />
      </Button>
      <Button href="#related-references-and-bibliography" variant="icon" title="Show bibliography">
        <Icon name="mi/outline/auto-stories" />
        <!-- <Icon name="mi/outline/arrow-downward" /> -->
      </Button>
      {
        principles && (
          <Button
            href={categorySectionUrl}
            variant="icon"
            title={`Back to ${currentSection?.title || 'section'}`}
          >
            <Icon name="mi/outline/apps" />
          </Button>
        )
      }
      <Button data-menu-toggle href="#" variant="icon" title="Show categories">
        <Icon name="mi/outline/menu" />
      </Button>
    </div>
  </div>
</Nav>
<script>
  function initSectionNavVisibility() {
    const sectionNav = document.querySelector('[data-top-nav]') as HTMLElement | null;
    const targetElement = document.querySelector('.header') as HTMLElement | null;
    if (!sectionNav || !targetElement) return;

    let lastScrollY = window.scrollY;
    let lastShowScrollY = window.scrollY;
    let isScrollingUp = false;
    let isTargetIntersecting = false;
    const SCROLL_THRESHOLD = 400;
    const SCROLL_TOP_THRESHOLD = SCROLL_THRESHOLD + 100;

    function updateNavVisibility() {
      if (!sectionNav) return;

      const currentScrollY = window.scrollY;
      const scrollDistance = currentScrollY - lastShowScrollY;

      // Show nav when scrolling up AND targetElement is not intersecting
      // Hide only when scrolling down AND scroll distance >= SCROLL_THRESHOLD AND targetElement is not intersecting
      let shouldShow = false;

      if (!isTargetIntersecting && currentScrollY > SCROLL_TOP_THRESHOLD) {
        if (isScrollingUp) {
          shouldShow = true;
          lastShowScrollY = currentScrollY; // Reset threshold when showing
        } else {
          if (scrollDistance >= SCROLL_THRESHOLD) {
            shouldShow = false; // Hide when scrolled down more than SCROLL_THRESHOLD
          } else {
            shouldShow = true; // Show if scroll distance < SCROLL_THRESHOLD
          }
        }
      }

      if (shouldShow) {
        sectionNav.classList.remove('-translate-y-full');
        sectionNav.classList.add('translate-y-0');
      } else {
        sectionNav.classList.add('-translate-y-full');
        sectionNav.classList.remove('translate-y-0');
      }
    }

    // Track scroll direction
    window.addEventListener(
      'scroll',
      () => {
        const currentScrollY = window.scrollY;
        isScrollingUp = currentScrollY < lastScrollY;
        lastScrollY = currentScrollY;
        updateNavVisibility();
      },
      { passive: true }
    );

    const observer = new IntersectionObserver(
      ([entry]) => {
        isTargetIntersecting = entry.isIntersecting;
        updateNavVisibility();
      },
      { threshold: 0 }
    );

    observer.observe(targetElement);
  }

  function initScrollToTop() {
    const scrollToTopButton = document.querySelector('[data-scroll-to-top-button]');
    if (!scrollToTopButton) return;

    scrollToTopButton.addEventListener('click', (e) => {
      e.preventDefault();

      // Remove hash from URL if present
      if (window.location.hash) {
        window.history.replaceState(null, '', window.location.pathname + window.location.search);
      }

      window.scrollTo({
        top: 0,
        behavior: 'smooth',
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initSectionNavVisibility();
      initScrollToTop();
    });
  } else {
    initSectionNavVisibility();
    initScrollToTop();
  }
</script>
