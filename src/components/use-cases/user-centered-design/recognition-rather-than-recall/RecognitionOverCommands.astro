---
import Usage from '../../../Usage.astro';
import UsageItem from '../../../UsageItem.astro';
import UseCase from '../../../UseCase.astro';
import UseCaseInteractive from '../../../UseCaseInteractive.astro';
---

<UseCase
  title="Recognition Over Commands"
  description="Interaction favors selection and recognition over memorizing commands or syntax."
>
  <UseCaseInteractive
    clsHeight={0}
    overflowHidden={false}
    articleId="recognition-over-commands"
    label="Autocomplete search"
  >
    <div class="w-full relative h-4000">
      <div class="grid gap-400">
        <mds-input
          data-search-input
          icon="mi/outline/search"
          placeholder='Digit "Vittorio" to see the autocomplete'
          type="text">
        </mds-input>
        <div class="grid gap-200">
          <mds-text typography="label">latest searches</mds-text>
          <div class="flex gap-200 flex-wrap">
            <mds-button variant="dark" tone="weak" data-search-button>Design</mds-button>
            <mds-button variant="dark" tone="weak" data-search-button>UX</mds-button>
            <mds-button variant="dark" tone="weak" data-search-button>Vittorio Vittori</mds-button>
            <mds-button variant="dark" tone="weak" data-search-button>Dog</mds-button>
            <mds-button variant="dark" tone="weak" data-search-button>Parent</mds-button>
          </div>
        </div>
      </div>
      <div
        class="hidden absolute top-1200 left-0 right-0 mt-200 bg-tone-neutral dark:bg-tone-neutral-09 rounded-lg shadow-sm-sharp border border-tone-neutral-03/20 z-10 max-h-4400 overflow-y-auto"
        data-autocomplete-results
      >
        <!-- Autocomplete results will be inserted here -->
      </div>
    </div>
    <script>
      function initAutocomplete() {
        console.log('initAutocomplete');
        const articleId = 'recognition-over-commands';
        const scope = (window as any).getUseCaseScope?.(articleId);
        if (!scope) return;
        const { container } = scope;
        const searchInput = container.querySelector('[data-search-input]') as HTMLElement;
        const resultsContainer = container.querySelector(
          '[data-autocomplete-results]'
        ) as HTMLElement;

        if (!searchInput || !resultsContainer) return;
        const autocompleteItems = [
          'Vittorio Vittori Design System Architect',
          'Vitto made ADV banners for Adobe',
          'Vitto made ADV banners for Microsoft',
          'Vitto made ADV banners for Phillips',
          'Vittori[o] why did his parents give him a modular name',
          'Vittorio Vittori UX Designer',
          'Vittorio Vittori had a dog named Fudo who remembers every day',
          'Vittorio loves accessibility',
        ];
        function highlightText(text: string, query: string): string {
          if (!query) return text;
          const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
          return text.replace(
            regex,
            '<mark class="bg-label-blue-08 text-label-blue-04 px-50 rounded-md">$1</mark>'
          );
        }
        function filterResults(query: string): string[] {
          if (!query) return [];
          const lowerQuery = query.toLowerCase();
          return autocompleteItems.filter((item) => item.toLowerCase().includes(lowerQuery));
        }
        function clearSearch() {
          console.log('clearSearch');
          const inputElement = searchInput as any;
          if (inputElement) {
            inputElement.value = '';
          }
          resultsContainer.classList.add('hidden');
          resultsContainer.innerHTML = '';
        }

        function renderResults(query: string) {
          // Only show autocomplete if query has at least 2 characters
          if (query.length < 2) {
            resultsContainer.classList.add('hidden');
            resultsContainer.innerHTML = '';
            return;
          }
          const filtered = filterResults(query);
          if (filtered.length === 0) {
            resultsContainer.classList.add('hidden');
            resultsContainer.innerHTML = '';
            return;
          }
          const totalResults = filtered.length;
          const maxResults = 4;
          const displayedResults = filtered.slice(0, maxResults);
          resultsContainer.classList.remove('hidden');
          const resultsHTML = displayedResults
            .map(
              (item, index) =>
                `<div class="px-400 py-100 hover:bg-tone-neutral-10 cursor-pointer border-b border-tone-neutral-03/10" data-result-item data-result-index="${index}"><mds-text typography="caption" class="text-tone-neutral-03">${highlightText(item, query)}</mds-text></div>`
            )
            .join('');
          const tipHTML =
            totalResults > maxResults
              ? `<div class="px-400 py-200 bg-tone-neutral-10 border-t border-tone-neutral-03/10"><mds-text typography="caption" class="text-tone-neutral-03">Showing ${maxResults} of ${totalResults} results</mds-text></div>`
              : `<div class="px-400 py-200 bg-tone-neutral-10 border-t border-tone-neutral-03/10"><mds-text typography="caption" class="text-tone-neutral-03">${totalResults} result${totalResults !== 1 ? 's' : ''}</mds-text></div>`;
          resultsContainer.innerHTML = resultsHTML + tipHTML;
        }

        // Use event delegation to handle clicks on result items
        // Using capture phase to catch clicks before child elements intercept them
        resultsContainer.addEventListener('click', (e: Event) => {
          const target = e.target as HTMLElement;
          // Check if click originated from a result item or its children
          const resultItem = target.closest('[data-result-item]');
          if (resultItem) {
            clearSearch();
          }
        }, { capture: true });

        function getInputValue(): string {
          const inputElement = searchInput as HTMLInputElement;
          return inputElement?.value || '';
        }
        function handleInputChange(event: Event) {
          const target = event.target as any;
          const value = target?.value || getInputValue();
          renderResults(value);
        }
        function handleInputBlur() {
          resultsContainer.classList.add('hidden');
          resultsContainer.innerHTML = '';
        }
        function handleInputFocus() {
          const value = getInputValue();
          if (value) {
            renderResults(value);
          }
        }
        searchInput.addEventListener('mdsInputChange', handleInputChange);
        searchInput.addEventListener('mdsInputBlur', handleInputBlur);
        searchInput.addEventListener('mdsInputFocus', handleInputFocus);

        // Handle button clicks to fill search input
        const searchButtons = container.querySelectorAll('[data-search-button]');
        searchButtons.forEach((button: HTMLElement) => {
          button.addEventListener('click', () => {
            const buttonText = button.textContent?.trim() || '';
            if (!buttonText) return;

            // Set the input value
            const inputElement = searchInput as any;
            if (inputElement) {
              inputElement.value = buttonText;

              // Trigger the search by dispatching mdsInputChange event
              const changeEvent = new CustomEvent('mdsInputChange', {
                bubbles: true,
                detail: { value: buttonText }
              });
              searchInput.dispatchEvent(changeEvent);
            }
          });
        });
      }
      function waitForComponents() {
        if (customElements.get('mds-input')) {
          initAutocomplete();
        } else {
          setTimeout(waitForComponents, 100);
        }
      }
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', waitForComponents);
      } else {
        waitForComponents();
      }
    </script>
  </UseCaseInteractive>
  <Usage>
    <UsageItem variant="do">Offer selectable options instead of commands</UsageItem>
    <UsageItem variant="dont">Require users to remember syntax</UsageItem>
    <UsageItem variant="do">Expose actions through buttons and menus</UsageItem>
    <UsageItem variant="dont">Hide core actions behind shortcuts only</UsageItem>
    <UsageItem variant="do">Use descriptive labels for actions</UsageItem>
    <UsageItem variant="dont">Rely on undocumented commands</UsageItem>
  </Usage>
</UseCase>
